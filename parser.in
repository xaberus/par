tokens {
  LINE_COMMENT(nil, func);
  MULTI_LINE_COMMENT(nil, func);

  FLOAT_CONSTANT(nil, func);
  HEX_INT_CONSTANT(nil, func);
  OCT_INT_CONSTANT(nil, func);
  DEC_INT_CONSTANT(nil, func);
  CHAR_CONSTANT(nil, func);
  STRING_CONSTANT(nil, func);

  AUTO(nil, K"auto");
  BOOL(nil, K"bool");
  CHAR(nil, K"char");
  COMPLEX(nil, K"complex");
  DOUBLE(nil, K"double");
  FLOAT(nil, K"float");
  IMAGINARY(nil, K"imaginary");
  INT8(nil, K"int8");
  INT16(nil, K"int16");
  INT32(nil, K"int32");
  INT64(nil, K"int64");
  LONG(nil, K"long");
  SHORT(nil, K"short");
  SIGNED(nil, K"signed");
  UINT8(nil, K"uint8");
  UINT16(nil, K"uint16");
  UINT32(nil, K"uint32");
  UINT64(nil, K"uint64");
  UNSIGNED(nil, K"unsigned");
  VOID(nil, K"void");

  NAMESPACE(nil, K"namespace");
  DECLARE(nil, K"declare");
  INTERFACE(nil, K"interface");
  SELFTYPE(nil, K"selftype");
  SELF(nil, K"self");

  /* must be here */
  INT(nil, K"int");

  IDENTIFIER(100, func);
  TYPE_NAME(200, func);

  BREAK(nil, K"break");
  CASE(nil, K"case");
  CONTINUE(nil, K"continue");
  DEFAULT(nil, K"default");
  DO(nil, K"do");
  ELSE(nil, K"else");
  ENUM(nil, K"enum");
  FOR(nil, K"for");
  GOTO(nil, K"goto");
  IF(nil, K"if");
  RETURN(nil, K"return");
  SIZEOF(nil, K"sizeof");
  STRUCT(nil, K"struct");
  SWITCH(nil, K"switch");
  TYPEDEF(nil, K"typedef");
  UNION(nil, K"union");
  WHILE(nil, K"while");

  CONST(nil, K"const");
  EXPORT(nil, K"export");
  EXTERN(nil, K"extern");
  HIDDEN(nil, K"hidden");
  INLINE(nil, K"inline");
  REGISTER(nil, K"register");
  RESTRICT(nil, K"restrict");
  STATIC(nil, K"static");
  VOLATILE(nil, K"volatile");

  ELLIPSIS(nil, "...");

  AND_OP(nil, "&&");
  DEC_OP(nil, "--");
  EQ_OP(nil, "==");
  GE_OP(nil, ">=");
  INC_OP(nil, "++");
  LEFT_OP(nil, "<<");
  LE_OP(nil, "<=");
  NE_OP(nil, "!=");
  OR_OP(nil, "||");
  PTR_OP(nil, "->");
  RIGHT_OP(nil, ">>");

  AMPERSAND(nil, "&");
  CIRCUMFLEX(nil, "^");
  DOT(nil, ".");
  GREATER(nil, ">");
  LESS(nil, "<");
  MINUS(nil, "-");
  PERCENT(nil, "%");
  PIPE(nil, "|");
  PLUS(nil, "+");
  SLASH(nil, "/");
  STAR(nil, "*");
  TILDE(nil, "~");

  ASSIGN(nil, "=");
  ADD_ASSIGN(nil, "+=");
  AND_ASSIGN(nil, "&=");
  DIV_ASSIGN(nil, "/=");
  LEFT_ASSIGN(nil, "<<=");
  MOD_ASSIGN(nil, "%=");
  MUL_ASSIGN(nil, "*=");
  OR_ASSIGN(nil, "|=");
  RIGHT_ASSIGN(nil, ">>=");
  SUB_ASSIGN(nil, "-=");
  XOR_ASSIGN(nil, "^=");

  COLON(nil, ":");
  COMMA(nil, ",");
  EXCLAMATION(nil, "!");
  QUESTION(nil, "?");
  SEMICOLON(nil, ";");

  L_BRACE(nil, "{");
  R_BRACE(nil, "}");
  L_BRACKET(nil, "[");
  R_BRACKET(nil, "]");
  L_PAREN(nil, "(");
  R_PAREN(nil, ")");

 /* ERROR(nil, error);*/
  END(0, eof);
}

primary_expression
  : IDENTIFIER
    @L{return Expression.Identifier($1)}@
  | SELF
    @L{return Expression.Self($1)}@
  | constant
    @L{return $1}@
  | L_PAREN expression R_PAREN
    @L{return $2:par()}@
  | L_PAREN compound_statement R_PAREN
    @L{return Expression.Statement($2)}@
  ;

constant
  : STRING_CONSTANT
    @L{return Expression.Constant("string", $1)}@
  | CHAR_CONSTANT
    @L{return Expression.Constant("char", $1)}@
  | OCT_INT_CONSTANT
    @L{return Expression.Constant("oct", $1)}@
  | DEC_INT_CONSTANT
    @L{return Expression.Constant("dec", $1)}@
  | HEX_INT_CONSTANT
    @L{return Expression.Constant("hex", $1)}@
  | FLOAT_CONSTANT
    @L{return Expression.Constant("float", $1)}@
  ;
  
postfix_expression
  : primary_expression
    @L{return $1}@
  | postfix_expression L_BRACKET expression R_BRACKET
    @L{return $1:add_index()}@
  | postfix_expression L_PAREN R_PAREN
    @L{return $1:add_call()}@
  | postfix_expression L_PAREN argument_expression_list R_PAREN
    @L{return $1:add_call($3)}@
  | postfix_expression DOT IDENTIFIER
    @L{return $1:acc_deref($3)}@
  | postfix_expression PTR_OP IDENTIFIER
    @L{return $1:acc_ptrderef($3)}@
  | postfix_expression INC_OP
    @L{return $1:inc()}@
  | postfix_expression DEC_OP
    @L{return $1:dec()}@
  | L_PAREN type_name R_PAREN L_BRACE initializer_list R_BRACE
    @L{return Expression.Construct($2, $5)}@
  | L_PAREN type_name R_PAREN L_BRACE initializer_list COMMA R_BRACE
    @L{return Expression.Construct($2, $5)}@
  ;

argument_expression_list
  : assignment_expression
    @L{return {$1}}@
  | argument_expression_list COMMA assignment_expression
    @L{return include($1, $3)}@
  ;

unary_expression
  : postfix_expression
    @L{return $1}@
  | INC_OP unary_expression
    @L{return $2:uinc()}@
  | DEC_OP unary_expression
    @L{return $2:udec()}@
  | AMPERSAND cast_expression
    @L{return $2:addr()}@
  | STAR cast_expression
    @L{return $2:deref()}@
  | PLUS cast_expression
    @L{return $2:unp()}@
  | MINUS cast_expression
    @L{return $2:unm()}@
  | TILDE cast_expression
    @L{return $2:bnot()}@
  | EXCLAMATION cast_expression
    @L{return $2:lnot()}@
  | SIZEOF unary_expression
    @L{return Expression.ExpressionSizeof($2)}@
  | SIZEOF L_PAREN type_name R_PAREN
    @L{return Expression.TypeSizeof($3)}@
  ;

cast_expression
  : unary_expression
    @L{return $1}@
  | L_PAREN type_name R_PAREN cast_expression
    @L{return $4:cast($2)}@
  ;


multiplicative_expression
  : cast_expression
    @L{return $1}@
  | multiplicative_expression STAR cast_expression
    @L{return $1:mul($3)}@
  | multiplicative_expression SLASH cast_expression
    @L{return $1:div($3)}@
  | multiplicative_expression PERCENT cast_expression
    @L{return $1:mod($3)}@
  ;

additive_expression
  : multiplicative_expression
    @L{return $1}@
  | additive_expression PLUS multiplicative_expression
    @L{return $1:add($3)}@
  | additive_expression MINUS multiplicative_expression
    @L{return $1:sub($3)}@
  ;

shift_expression
  : additive_expression
    @L{return $1}@
  | shift_expression LEFT_OP additive_expression
    @L{return $1:shl($3)}@
  | shift_expression RIGHT_OP additive_expression
    @L{return $1:shr($3)}@
  ;

relational_expression
  : shift_expression
    @L{return $1}@
  | relational_expression LESS shift_expression
    @L{return $1:ls($3)}@
  | relational_expression GREATER shift_expression
    @L{return $1:gt($3)}@
  | relational_expression LE_OP shift_expression
    @L{return $1:le($3)}@
  | relational_expression GE_OP shift_expression
    @L{return $1:ge($3)}@
  ;

equality_expression
  : relational_expression
    @L{return $1}@
  | equality_expression EQ_OP relational_expression
    @L{return $1:eq($3)}@
  | equality_expression NE_OP relational_expression
    @L{return $1:ne($3)}@
  ;

and_expression
  : equality_expression
    @L{return $1}@
  | and_expression AMPERSAND equality_expression
    @L{return $1:band($3)}@
  ;

exclusive_or_expression
  : and_expression
    @L{return $1}@
  | exclusive_or_expression CIRCUMFLEX and_expression
    @L{return $1:bxor($3)}@
  ;

inclusive_or_expression
  : exclusive_or_expression
    @L{return $1}@
  | inclusive_or_expression PIPE exclusive_or_expression
    @L{return $1:bor($3)}@
  ;

logical_and_expression
  : inclusive_or_expression
    @L{return $1}@
  | logical_and_expression AND_OP inclusive_or_expression
    @L{return $1:land($3)}@
  ;

logical_or_expression
  : logical_and_expression
    @L{return $1}@
  | logical_or_expression OR_OP logical_and_expression
    @L{return $1:lor($3)}@
  ;

conditional_expression
  : logical_or_expression
    @L{return $1}@
  | logical_or_expression QUESTION expression COLON conditional_expression
    @L{return $1:cond($3, $5)}@
  ;

assignment_expression
  : conditional_expression
    @L{return $1}@
  | unary_expression ASSIGN assignment_expression
    @L{return $1:asgn($3)}@
  | unary_expression MUL_ASSIGN assignment_expression
    @L{return $1:mul_asgn($3)}@
  | unary_expression DIV_ASSIGN assignment_expression
    @L{return $1:div_asgn($3)}@
  | unary_expression MOD_ASSIGN assignment_expression
    @L{return $1:mod_asgn($3)}@
  | unary_expression ADD_ASSIGN assignment_expression
    @L{return $1:add_asgn($3)}@
  | unary_expression SUB_ASSIGN assignment_expression
    @L{return $1:sub_asgn($3)}@
  | unary_expression LEFT_ASSIGN assignment_expression
    @L{return $1:shl_asgn($3)}@
  | unary_expression RIGHT_ASSIGN assignment_expression
    @L{return $1:shr_asgn($3)}@
  | unary_expression AND_ASSIGN assignment_expression
    @L{return $1:band_asgn($3)}@
  | unary_expression XOR_ASSIGN assignment_expression
    @L{return $1:bxor_asgn($3)}@
  | unary_expression OR_ASSIGN assignment_expression
    @L{return $1:bor_asgn($3)}@
  ;

expression
  : assignment_expression
    @L{return $1}@
  | expression COMMA assignment_expression
    @L{
      if $1.list then
        include($1.list, $3)
        return $1
      else
        $1 = $1:List()
        include($1.list, $3)
        return $1
      end
    }@
  ;

constant_expression
  : conditional_expression
    @L{return $1}@
  ;

/**************************************************************************/
/***   ***   ***   ***   ***   ***   ***   ***  ***   ***   ***   ***   ***/
/***   ***   ***   ***   ***   ***   ***   ***  ***   ***   ***   ***   ***/
/***   ***   ***   ***   ***   ***   ***   ***  ***   ***   ***   ***   ***/
/**************************************************************************/

declaration
  : type_name init_declarator_list SEMICOLON
    @L{return Declaration.Plain(nil, $1, $2)}@
  | TYPEDEF type_name IDENTIFIER SEMICOLON
    @L{return Declaration.Typefef($3, env:type_reg($3.value, $2))}@
  | storage_class_specifier type_name init_declarator_list SEMICOLON
    @L{return Declaration.Plain($1, $2, $3)}@
  |  struct_or_union_definition SEMICOLON
    @L{return Declaration.Struct($1)}@
  |  enum_definition SEMICOLON
    @L{return Declaration.Enum($1)}@
  ;

struct_or_union_definition
  : struct_or_union IDENTIFIER L_BRACE struct_declaration_list R_BRACE
    @L{return env:struct_reg($2.value, Struct.Named($2, $1, $4))}@
  ;

enum_definition
  : ENUM IDENTIFIER L_BRACE enumerator_list R_BRACE
    @L{return env:enum_reg($2.value, Enum.Named($2, $4))}@
  | ENUM IDENTIFIER L_BRACE enumerator_list COMMA R_BRACE
    @L{return env:enum_reg($2.value, Enum.Named($2, $4))}@
  ;


init_declarator_list
  : init_declarator
    @L{return {$1}}@
  | init_declarator_list COMMA init_declarator
    @L{return include($1, $3)}@
  ;

init_declarator
  : IDENTIFIER
    @L{return {id = $1}}@
  | IDENTIFIER ASSIGN initializer
    @L{return {id = $1, init = $3}}@
  ;

storage_class_specifier
  : EXTERN
    @L{return $1}@
  | STATIC
    @L{return $1}@
  | AUTO
    @L{return $1}@
  | REGISTER
    @L{return $1}@
  ;

type_specifier
  : VOID
    @L{return $1}@
  | CHAR
    @L{return $1}@
  | SHORT
    @L{return $1}@
  | INT
    @L{return $1}@
  | LONG
    @L{return $1}@
  | FLOAT
    @L{return $1}@
  | DOUBLE
    @L{return $1}@
  | SIGNED
    @L{return $1}@
  | UNSIGNED
    @L{return $1}@
  | BOOL
    @L{return $1}@
  | COMPLEX
    @L{return $1}@
  | IMAGINARY
    @L{return $1}@
  | struct_or_union_specifier
    @L{return $1}@
  | enum_specifier
    @L{return $1}@
  | TYPE_NAME
    @L{return $1}@
  | INT8
    @L{return $1}@
  | INT16
    @L{return $1}@
  | INT32
    @L{return $1}@
  | INT64
    @L{return $1}@
  | UINT8
    @L{return $1}@
  | UINT16
    @L{return $1}@
  | UINT32
    @L{return $1}@
  | UINT64
    @L{return $1}@
  | SELFTYPE
    @L{return $1}@
  ;

struct_or_union_specifier
  : struct_or_union IDENTIFIER
    @L{return env:struct_get($2.value)}@
  | struct_or_union L_BRACE struct_declaration_list R_BRACE
    @L{return Struct.Anonymous($1, $3)}@
  ;

struct_or_union
  : STRUCT
    @L{return $1}@
  | UNION
    @L{return $1}@
  ;

struct_declaration_list
  : struct_declaration
    @L{return {$1}}@
  | struct_declaration_list struct_declaration
    @L{return include($1, $2)}@
  ;

struct_declaration
  : type_name struct_declarator_list SEMICOLON
    @L{return {type = $1, fields = $2}}@
  | type_name SEMICOLON
    @L{return {type = Struct.MakeHeadless($1)}}@
  ;

specifier_qualifier_list
  : type_specifier specifier_qualifier_list
    @L{return merge({{specifier = $1}}, $2)}@
  | type_specifier
    @L{return {{specifier = $1}}}@
  | type_qualifier specifier_qualifier_list
    @L{return merge({{qualifier = $1}}, $2)}@
  | type_qualifier
    @L{return {{qualifier = $1}}}@
  ;

struct_declarator_list
  : struct_declarator
    @L{return {$1}}@
  | struct_declarator_list COMMA struct_declarator
    @L{return include($1, $3)}@
  ;

struct_declarator
  : IDENTIFIER
    @L{return {id = $1}}@
  | IDENTIFIER COLON constant_expression
    @L{return {id = $1, depth = $3}}@
  ;

/*
  | ENUM IDENTIFIER L_BRACE enumerator_list R_BRACE
    @L{}@
  | ENUM IDENTIFIER L_BRACE enumerator_list COMMA R_BRACE
    @L{}@*/

/* XXX enum! */
enum_specifier
  : ENUM L_BRACE enumerator_list R_BRACE
    @L{return Enum.Anonymous($3)}@
  | ENUM L_BRACE enumerator_list COMMA R_BRACE
    @L{return Enum.Anonymous($3)}@
  | ENUM IDENTIFIER
    @L{return env:enum_get($2.value)}@
  ;

enumerator_list
  : enumerator
    @L{return {$1}}@
  | enumerator_list COMMA enumerator
    @L{return include($1, $3)}@
  ;

enumerator
  : IDENTIFIER
    @L{return {id = $1}}@
  | IDENTIFIER ASSIGN constant_expression
    @L{return {id = $1, constant = $3}}@
  ;

type_qualifier
  : CONST
    @L{return $1}@
  | RESTRICT
    @L{return $1}@
  | VOLATILE
    @L{return $1}@
  ;

pointer
  : STAR
    @L{return {{ref = $1}}}@
  | STAR type_qualifier_list
    @L{return {{ref = $1, qualifiers = $2}}}@
  | STAR pointer
    @L{return merge({{ref = $1}}, $2)}@
  | STAR type_qualifier_list pointer
    @L{return merge({{ref = $1, qualifiers = $2}}, $3)}@
  ;

type_qualifier_list
  : type_qualifier
    @L{return {$1}}@
  | type_qualifier_list type_qualifier
    @L{return include($1, $2)}@
  ;


parameter_type_list
  : parameter_list
    @L{return $1}@
  | parameter_list COMMA ELLIPSIS
    @L{return include($1, {vararg = true})}@
  ;

parameter_list
  : parameter_declaration
    @L{return {$1}}@
  | parameter_list COMMA parameter_declaration
    @L{return include($1, $3)}@
  ;

parameter_declaration
  : type_name IDENTIFIER
    @L{return Parameter($2, $1)}@
  ;

type_name
  : specifier_qualifier_list
    @L{return Type.Plain($1)}@
  | specifier_qualifier_list abstract_declarator
    @L{return Type.Abstract($1, $2)}@
  ;

abstract_declarator
  : pointer
    @L{return {pointer = $1}}@
  | direct_abstract_declarator
    @L{return {abstract = $1}}@
  | pointer direct_abstract_declarator
    @L{return {pointer = $1, abstract = $2}}@
  ;

/*
  TODO: find out if removed too much

direct_declarator
  : IDENTIFIER
  | L_PAREN declarator R_PAREN
  | direct_declarator L_BRACKET type_qualifier_list assignment_expression R_BRACKET
  | direct_declarator L_BRACKET type_qualifier_list R_BRACKET
  | direct_declarator L_BRACKET assignment_expression R_BRACKET
  | direct_declarator L_BRACKET STATIC type_qualifier_list assignment_expression R_BRACKET
  | direct_declarator L_BRACKET type_qualifier_list STATIC assignment_expression R_BRACKET
  | direct_declarator L_BRACKET type_qualifier_list STAR R_BRACKET
  | direct_declarator L_BRACKET STAR R_BRACKET
  | direct_declarator L_BRACKET R_BRACKET
  | direct_declarator L_PAREN parameter_type_list R_PAREN
  | direct_declarator L_PAREN identifier_list R_PAREN
  | direct_declarator L_PAREN R_PAREN
  ;
*/

direct_abstract_declarator
  : L_PAREN abstract_declarator R_PAREN
    @L{return {{parens = $1}}}@
  | L_BRACKET R_BRACKET
    @L{return {{vararray = true}}}@
  | L_BRACKET assignment_expression R_BRACKET
    @L{return {{array = true, size = $2}}}@
  | direct_abstract_declarator L_BRACKET R_BRACKET
    @L{return include($1, {vararray = true})}@
  | direct_abstract_declarator L_BRACKET assignment_expression R_BRACKET
    @L{return include($1, {array = true, size = $3})}@
  | L_BRACKET STAR R_BRACKET
    /*@L{XXX}*/
  | direct_abstract_declarator L_BRACKET STAR R_BRACKET
    /*@L{XXX}*/
  | L_PAREN R_PAREN
    @L{return {{params = {}}}}@
  | L_PAREN parameter_type_list R_PAREN
    @L{return {{params = $2}}}@
  | direct_abstract_declarator L_PAREN R_PAREN
    @L{return include($1, {params = {}})}@
  | direct_abstract_declarator L_PAREN parameter_type_list R_PAREN
    @L{return include($1, {params = $3})}@
  ;

initializer
  : assignment_expression
    @L{return Initializer.Plain($1)}@
  | L_BRACE initializer_list R_BRACE
    @L{return Initializer.List($2)}@
  | L_BRACE initializer_list COMMA R_BRACE
    @L{return Initializer.List($2)}@
  ;

initializer_list
  : initializer
    @L{return {{init = $1}}}@
  | designation initializer
    @L{return {{designation = $1, init = $2}}}@
  | initializer_list COMMA initializer
    @L{return include($1, {init = $3})}@
  | initializer_list COMMA designation initializer
    @L{return include($1, {designation = $3, init = $4})}@
  ;

designation
  : designator_list ASSIGN
    @L{return $1}@
  ;

designator_list
  : designator
    @L{return {$1}}@
  | designator_list designator
    @L{return include($1, $2)}@
  ;

designator
  : L_BRACKET constant_expression R_BRACKET
    @L{return {indexer = $2}}@
  | DOT IDENTIFIER
    @L{return {namer = $2}}@
  ;

statement
  : closed_statement
    @L{return $1}@
  | opened_statement
    @L{return $1}@
  ;

if_clause
  : IF L_PAREN expression R_PAREN
    @L{return {ifclause = true, expr = $3}}@
  ;

do_clause
  : DO
    @L{return {doclause = true}}@
  ;

for_clause
  : FOR L_PAREN expression_statement expression_statement R_PAREN
    @L{return {forclause="ee", initexpr = $3, runexpr = $4}}@
  | FOR L_PAREN expression_statement expression_statement expression R_PAREN
    @L{return {forclause="eee", initexpr = $3, runexpr = $4, doexpr = $5}}@
  | FOR L_PAREN declaration expression_statement R_PAREN
    @L{return {forclause="de", decl = $3, runexpr = $4}}@
  | FOR L_PAREN declaration expression_statement expression R_PAREN
    @L{return {forclause="dee", decl = $3, runexpr = $4, doexpr = $5}}@
  ;

while_clause
  : WHILE L_PAREN expression R_PAREN
    @L{return {whileclause = true, expr = $3}}@
  ;

label
  : IDENTIFIER COLON
    @L{return {label = $1}}@
  | CASE constant_expression COLON
    @L{return {case = $2}}@
  | DEFAULT COLON
    @L{return {default = true}}@
  ;

switch_clause
  : SWITCH L_PAREN expression R_PAREN
    @L{return {switchclause = true, expr = $3}}@
  ;


opened_statement
  : if_clause statement
    @L{return Statement.If(true, $1, $2)}@
  | if_clause closed_statement ELSE opened_statement
    @L{return Statement.IfElse(true, $1, $2, $4)}@
  | do_clause opened_statement while_clause SEMICOLON
    @L{return Statement.Do(true, $1, $2, $3)}@
  | for_clause opened_statement
    @L{return Statement.For(true, $1, $2)}@
  | while_clause opened_statement
    @L{return Statement.While(true, $1, $2)}@
  ;

closed_statement
  : if_clause closed_statement ELSE closed_statement
    @L{return Statement.IfElse(false, $1, $2, $4)}@
  | do_clause closed_statement while_clause SEMICOLON
    @L{return Statement.Do(false, $1, $2, $3)}@
  | for_clause closed_statement
    @L{return Statement.For(false, $1, $2)}@
  | while_clause closed_statement
    @L{return Statement.While(false, $1, $2)}@
  | expression_statement


    @L{return Statement.Expression($1)}@
  | jump_statement
    @L{return Statement.Jump($1)}@
  | label
    @L{return Statement.Label($1)}@
  | switch_clause compound_statement
    @L{return Statement.Switch($1)}@
  | compound_statement
    @L{return Statement.Compound($1)}@
  ;

compound_statement
  : L_BRACE R_BRACE
  | L_BRACE block_item_list R_BRACE
    @L{return Block.List($2)}@
  ;


block_item_list
  : block_item
    @L{return {$1}}@
  | block_item_list block_item
    @L{return include($1, $2)}@
  ;

block_item
  : declaration
    @L{return {decl = $1}}@
  | statement
    @L{return {statement = $1}}@
  ;

expression_statement
  : SEMICOLON
    @L{return {}}@
  | expression SEMICOLON
    @L{return $1}@
  ;


jump_statement
  : GOTO IDENTIFIER SEMICOLON
    @L{return {goto = $2}}@
  | CONTINUE SEMICOLON
    @L{return {continue = true}}@
  | BREAK SEMICOLON
    @L{return {breaker = true}}@
  | RETURN SEMICOLON
    @L{return {returner = true}}@
  | RETURN expression SEMICOLON
    @L{return {returner = true, value = $2}}@
  ;

source
  : translation_unit
    @L{return env:set_ast($1)}@
  ;

translation_unit
  : external_declaration
    @L{return {$1}}@
  | translation_unit external_declaration
    @L{return include($1, $2)}@
  ;

external_declaration
  : function_definition
    @L{return {func = $1}}@
  | declaration
    @L{return {decl = $1}}@
  | interface_definition
  | namespace
  ;

namespace
  : NAMESPACE IDENTIFIER L_BRACE R_BRACE SEMICOLON
  | NAMESPACE IDENTIFIER L_BRACE namespace_declaration R_BRACE SEMICOLON
  ;

namespace_declaration
  : external_declaration
  | namespace_declaration external_declaration
  ;

interface_definition
  : INTERFACE IDENTIFIER L_BRACE interface_declaration interface_definition_block R_BRACE SEMICOLON
  ;

interface_declaration
  : DECLARE struct_or_union_specifier SEMICOLON
  ;


interface_definition_block
  : method_definition_list
  | interface_derrivation method_definition_list
  ;

interface_derrivation
  : INTERFACE IDENTIFIER SEMICOLON
  | INTERFACE IDENTIFIER L_BRACE method_definition_list R_BRACE SEMICOLON
  ;

method_definition_list
  : method_definition
  | method_definition_list method_definition
  ;

method_definition
  : function_definition
  ;

function_specifier_list
  : function_specifier
    @L{return {$1}}@
  | function_specifier_list function_specifier
    @L{return include($1, $2)}@
  ;

function_specifier
  : INLINE
    @L{return $1}@
  | EXPORT
    @L{return $1}@
  | HIDDEN
    @L{return $1}@
  ;

function_definition
  : type_name IDENTIFIER L_PAREN R_PAREN compound_statement
    @L{return Function(nil, $1, $2, $5)}@
  | function_specifier_list type_name IDENTIFIER L_PAREN R_PAREN compound_statement
    @L{return Function(nil, $1, $2, $6)}@
  | type_name IDENTIFIER L_PAREN parameter_type_list R_PAREN compound_statement
    @L{return Function(nil, $1, $2, $4, $6)}@
  | function_specifier_list type_name IDENTIFIER L_PAREN parameter_type_list R_PAREN compound_statement
    @L{return Function($1, $2, $3, $5, $7)}@

  | type_name IDENTIFIER L_PAREN R_PAREN SEMICOLON
    @L{return Function.Abstract(nil, $1, $2)}@
  | function_specifier_list type_name IDENTIFIER L_PAREN R_PAREN SEMICOLON
    @L{return Function.Abstract(nil, $1, $2)}@
  | type_name IDENTIFIER L_PAREN parameter_type_list R_PAREN SEMICOLON
    @L{return Function.Abstract(nil, $1, $2, $4)}@
  | function_specifier_list type_name IDENTIFIER L_PAREN parameter_type_list R_PAREN SEMICOLON
    @L{return Function.Abstract($1, $2, $3, $5)}@

  ;

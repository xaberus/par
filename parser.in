tokens {
  LINE_COMMENT(1000) {
    local write = ...
    write([[( P"//" * ( P(1) - nl )^0  )]])
  };

  MULTI_LINE_COMMENT(1001) {
    local write = ...
    write([[( P"/*" * ( ((P(1) - P"*/") - nl) + nl)^0 * "*/" ) ]])
  };


  FLOAT_CONSTANT(2000) {
    local write = ...
    write([[ ((
      R"09"^1 * S'eE' * S'+-'^-1 * R"09"^1 * (S'fFlL')^-1
      + R"09"^0 * P"." * R"09"^1 * (S'eE' * S'+-'^-1 * R"09"^1)^-1 * (S'fFlL')^-1
      + R"09"^1 * P"." * R"09"^0 * (S'eE' * S'+-'^-1 * R"09"^1)^-1 * (S'fFlL')^-1)) ]])
  };

  HEX_INT_CONSTANT(2001) {
    local write = ...
    write([[( P"0" * S"xX" * (R"09" + R"af" + R"AF")^1 * (S'uUlL'^0)^-1 )]])
  };

  OCT_INT_CONSTANT(2002) {
    local write = ...
    write([[( P"0" * (R"07")^1  * (S'uUlL'^0)^-1 )]])
  };

  DEC_INT_CONSTANT(2003) {
    local write = ...
    write([[( P"0" + (R"19" * R"09"^0)  * (S'uUlL'^0)^-1 )]])
  };

  CHAR_CONSTANT(2004) {
    local write = ...
    write([[  (P'L'^-1 * P"'" * (P'\\' * P(1) + (1 - S"\\'"))^1 * P"'")  ]])
  };

  STRING_CONSTANT(2005) {
    local write = ...
    write([[  (P'L'^-1 * P'"' * (P'\\' * P(1) + (1 - S'\\"'))^0 * P'"' * ws^0)^1  ]])
  };

  AUTO(nil, K"auto");
  BOOL(nil, K"bool");
  CHAR(nil, K"char");
  COMPLEX(nil, K"complex");
  DOUBLE(nil, K"double");
  FLOAT(nil, K"float");
  IMAGINARY(nil, K"imaginary");
  INT8(nil, K"int8");
  INT16(nil, K"int16");
  INT32(nil, K"int32");
  INT64(nil, K"int64");
  LONG(nil, K"long");
  SHORT(nil, K"short");
  SIGNED(nil, K"signed");
  UINT8(nil, K"uint8");
  UINT16(nil, K"uint16");
  UINT32(nil, K"uint32");
  UINT64(nil, K"uint64");
  UNSIGNED(nil, K"unsigned");
  VOID(nil, K"void");

  NAMESPACE(nil, K"namespace");
  DECLARE(nil, K"declare");
  INTERFACE(nil, K"interface");
  SELFTYPE(nil, K"selftype");
  SELF(nil, K"self");

  /* must be here */
  INT(nil, K"int");

  IDENTIFIER(100) {
    local write = ...
    write([[( ((R"AZ" + R"az" + S"_") *  (R"AZ" + R"az" + S"_" + R"09")^0)-(keywords*(-(R"AZ" + R"az" + S"_" + R"09"))) )]])
  };
  TYPE_NAME(200) {
    local write = ...
    write([[P(false)]])
  };

  BREAK(nil, K"break");
  CASE(nil, K"case");
  CONTINUE(nil, K"continue");
  DEFAULT(nil, K"default");
  DO(nil, K"do");
  ELSE(nil, K"else");
  ENUM(nil, K"enum");
  FOR(nil, K"for");
  GOTO(nil, K"goto");
  IF(nil, K"if");
  RETURN(nil, K"return");
  SIZEOF(nil, K"sizeof");
  STRUCT(nil, K"struct");
  SWITCH(nil, K"switch");
  TYPEDEF(nil, K"typedef");
  UNION(nil, K"union");
  WHILE(nil, K"while");

  CONST(nil, K"const");
  EXPORT(nil, K"export");
  EXTERN(nil, K"extern");
  HIDDEN(nil, K"hidden");
  INLINE(nil, K"inline");
  REGISTER(nil, K"register");
  RESTRICT(nil, K"restrict");
  STATIC(nil, K"static");
  VOLATILE(nil, K"volatile");

  ELLIPSIS(nil, "...");

  AND_OP(nil, "&&");
  DEC_OP(nil, "--");
  EQ_OP(nil, "==");
  GE_OP(nil, ">=");
  INC_OP(nil, "++");
  LEFT_OP(nil, "<<");
  LE_OP(nil, "<=");
  NE_OP(nil, "!=");
  OR_OP(nil, "||");
  PTR_OP(nil, "->");
  RIGHT_OP(nil, ">>");

  ADD_ASSIGN(nil, "+=");
  AND_ASSIGN(nil, "&=");
  DIV_ASSIGN(nil, "/=");
  LEFT_ASSIGN(nil, "<<=");
  MOD_ASSIGN(nil, "%=");
  MUL_ASSIGN(nil, "*=");
  OR_ASSIGN(nil, "|=");
  RIGHT_ASSIGN(nil, ">>=");
  SUB_ASSIGN(nil, "-=");
  XOR_ASSIGN(nil, "^=");

  ASSIGN(nil, "=");

  AMPERSAND(nil, "&");
  CIRCUMFLEX(nil, "^");
  DOT(nil, ".");
  GREATER(nil, ">");
  LESS(nil, "<");
  MINUS(nil, "-");
  PERCENT(nil, "%");
  PIPE(nil, "|");
  PLUS(nil, "+");
  SLASH(nil, "/");
  STAR(nil, "*");
  TILDE(nil, "~");


  COLON(nil, ":");
  COMMA(nil, ",");
  EXCLAMATION(nil, "!");
  QUESTION(nil, "?");
  SEMICOLON(nil, ";");

  L_BRACE(nil, "{");
  R_BRACE(nil, "}");
  L_BRACKET(nil, "[");
  R_BRACKET(nil, "]");
  L_PAREN(nil, "(");
  R_PAREN(nil, ")");

 /* ERROR(nil, error);*/
  END(0, eof);
}

primary_expression
  : IDENTIFIER {
      return {iden = $1}
    }
  | SELF {
      return {self = "self"}
    }
  | constant {
      return {const = $1}
    }
  | L_PAREN expression R_PAREN {
      return {par = $2}
    }
  | L_PAREN compound_statement R_PAREN {
      return {compound = $2}
    }
  ;

constant
  : STRING_CONSTANT {
      return {string = $1}
    }
  | CHAR_CONSTANT{
      return {char = $1}
    }
  | OCT_INT_CONSTANT{
      return {oct = $1}
    }
  | DEC_INT_CONSTANT{
      return {dec = $1}
    }
  | HEX_INT_CONSTANT{
      return {hex = $1}
    }
  | FLOAT_CONSTANT{
      return {float = $1}
    }
  ;

postfix_expression
  : primary_expression {
      return $1
    }
  | postfix_expression L_BRACKET expression R_BRACKET {
      return {index = $1, expr = $3}
    }
  | postfix_expression L_PAREN R_PAREN {
      return {call = $1, args = {list={}}}
    }
  | postfix_expression L_PAREN argument_expression_list R_PAREN {
      return {call = $1, args = {list=$3}}
    }
  | postfix_expression DOT IDENTIFIER {
      return {dot = $1, iden = $3}
    }
  /*| postfix_expression PTR_OP IDENTIFIER*/
  | postfix_expression INC_OP {
      return {inc = $1}
    }
  | postfix_expression DEC_OP {
      return {dec = $1}
    }
  | L_PAREN type_name R_PAREN L_BRACE initializer_list R_BRACE {
      return {tc = $2, list = $5}
    }
  | L_PAREN type_name R_PAREN L_BRACE initializer_list COMMA R_BRACE {
      return {tc = $2, list = $5}
    }
  ;

argument_expression_list
  : assignment_expression {
      return {$1}
    }
  | argument_expression_list COMMA assignment_expression {
      $1[#$1+1] = $3
      return $1
    }
  ;

unary_expression
  : postfix_expression {
      return $1
    }
  | INC_OP unary_expression {
      return {uinc = $2}
    }
  | DEC_OP unary_expression {
      return {udec = $2}
    }
  | AMPERSAND cast_expression {
      return {addr = $2}
    }
  | STAR cast_expression {
      return {deref = $2}
    }
  | PLUS cast_expression {
      return {unp = $2}
    }
  | MINUS cast_expression {
      return {unm = $2}
    }
  | TILDE cast_expression {
      return {bnot = $2}
    }
  | EXCLAMATION cast_expression {
      return {lnot = $2}
    }
  | SIZEOF unary_expression {
      return {sizeof = $2}
    }
  | SIZEOF L_PAREN type_name R_PAREN {
      return {fsizeof = $3}
    }
  ;

cast_expression
  : unary_expression {
      return $1
    }
  | L_PAREN type_name R_PAREN cast_expression {
      return {cast = $4, ctype = $2}
    }
  ;


multiplicative_expression
  : cast_expression {
      return $1
    }
  | multiplicative_expression STAR cast_expression {
      return {mul = $1, expr = $3}
    }
  | multiplicative_expression SLASH cast_expression {
      return {div = $1, expr = $3}
    }
  | multiplicative_expression PERCENT cast_expression {
      return {mod = $1, expr = $3}
    }
  ;

additive_expression
  : multiplicative_expression {
      return $1
    }
  | additive_expression PLUS multiplicative_expression {
      return {add = $1, expr = $3}
    }
  | additive_expression MINUS multiplicative_expression {
      return {sub = $1, expr = $3}
    }
  ;

shift_expression
  : additive_expression {
      return $1
    }
  | shift_expression LEFT_OP additive_expression {
      return {shl = $1, expr = $3}
    }
  | shift_expression RIGHT_OP additive_expression {
      return {shr = $1, expr = $3}
    }
  ;

relational_expression
  : shift_expression {
      return $1
    }
  | relational_expression LESS shift_expression {
      return {ls = $1, expr = $3}
    }
  | relational_expression GREATER shift_expression {
      return {gt = $1, expr = $3}
    }
  | relational_expression LE_OP shift_expression {
      return {le = $1, expr = $3}
    }
  | relational_expression GE_OP shift_expression {
      return {ge = $1, expr = $3}
    }
  ;

equality_expression
  : relational_expression {
      return $1
    }
  | equality_expression EQ_OP relational_expression {
      return {eq = $1, expr = $3}
    }
  | equality_expression NE_OP relational_expression {
      return {ne = $1, expr = $3}
    }
  ;

and_expression
  : equality_expression {
      return $1
    }
  | and_expression AMPERSAND equality_expression {
      return {band = $1, expr = $3}
    }
  ;

exclusive_or_expression
  : and_expression {
      return $1
    }
  | exclusive_or_expression CIRCUMFLEX and_expression {
      return {bxor = $1, expr = $3}
    }
  ;

inclusive_or_expression
  : exclusive_or_expression {
      return $1
    }
  | inclusive_or_expression PIPE exclusive_or_expression {
      return {bor = $1, expr = $3}
    }
  ;

logical_and_expression
  : inclusive_or_expression {
      return $1
    }
  | logical_and_expression AND_OP inclusive_or_expression {
      return {land = $1, expr = $3}
    }
  ;

logical_or_expression
  : logical_and_expression {
      return $1
    }
  | logical_or_expression OR_OP logical_and_expression {
      return {lor = $1, expr = $3}
    }
  ;

conditional_expression
  : logical_or_expression {
      return $1
    }
  | logical_or_expression QUESTION expression COLON conditional_expression {
      return {cond = $1, texpr = $3, fexpr = $5}
    }
  ;

assignment_expression
  : conditional_expression {
      return $1
    }
  | unary_expression ASSIGN assignment_expression {
      return {asgn = $1, expr = $3}
    }
  | unary_expression MUL_ASSIGN assignment_expression {
      return {mul_asgn = $1, expr = $3}
    }
  | unary_expression DIV_ASSIGN assignment_expression {
      return {div_asgn = $1, expr = $3}
    }
  | unary_expression MOD_ASSIGN assignment_expression {
      return {mod_asgn = $1, expr = $3}
    }
  | unary_expression ADD_ASSIGN assignment_expression {
      return {add_asgn = $1, expr = $3}
    }
  | unary_expression SUB_ASSIGN assignment_expression {
      return {sub_asgn = $1, expr = $3}
    }
  | unary_expression LEFT_ASSIGN assignment_expression {
      return {shl_asgn = $1, expr = $3}
    }
  | unary_expression RIGHT_ASSIGN assignment_expression {
      return {shr_asgn = $1, expr = $3}
    }
  | unary_expression AND_ASSIGN assignment_expression {
      return {band_asgn = $1, expr = $3}
    }
  | unary_expression XOR_ASSIGN assignment_expression {
      return {bxor_asgn = $1, expr = $3}
    }
  | unary_expression OR_ASSIGN assignment_expression {
      return {bor_asgn = $1, expr = $3}
    }
  ;

expression
  : assignment_expression {
      return {list = {$1}}
    }
  | expression COMMA assignment_expression {
      $1.list[#$1.list+1] = $3
      return $1
    }
  ;

constant_expression
  : conditional_expression {
      return $1
    }
  ;

/**************************************************************************/
/***   ***   ***   ***   ***   ***   ***   ***  ***   ***   ***   ***   ***/
/***   ***   ***   ***   ***   ***   ***   ***  ***   ***   ***   ***   ***/
/***   ***   ***   ***   ***   ***   ***   ***  ***   ***   ***   ***   ***/
/**************************************************************************/

declaration
  : type_name init_declarator_list SEMICOLON {
      return {pure = true, decl = $2, ctype = $1}
    }
  | TYPEDEF type_name IDENTIFIER SEMICOLON {
      local tdef = {tdef = true, tdef = $3, ctype = $2}
      env.current:type_reg($3.value, {loc = tdef})
      --dump(env.current)
      return tdef
    }
  | storage_class_specifier type_name init_declarator_list SEMICOLON {
      return {decl = $3, ctype = $2, spec = $1}
    }
  | struct_or_union_definition SEMICOLON {
      return $1
    }
  | enum_definition SEMICOLON {
      return $1
    }
  ;

struct_or_union_definition
  : struct_or_union IDENTIFIER L_BRACE struct_declaration_list R_BRACE {
      return {[$1.value] = true, iden = $2, decl = $4}
    }
  ;

enum_definition
  : ENUM IDENTIFIER L_BRACE enumerator_list R_BRACE {
      return {enum = $2, list = $4}
    }
  | ENUM IDENTIFIER L_BRACE enumerator_list COMMA R_BRACE {
      return {enum = $2, list = $4}
    }
  ;


init_declarator_list
  : init_declarator {
      return {$1}
    }
  | init_declarator_list COMMA init_declarator {
      $1[#$1+1] = $3
      return $1
    }
  ;

init_declarator
  : IDENTIFIER {
      return {iden = $1}
    }
  | IDENTIFIER ASSIGN initializer {
      return {iden = $1, init = $3}
    }
  ;

storage_class_specifier
  : EXTERN {
      return $1
    }
  | STATIC {
      return $1
    }
  | AUTO {
      return $1
    }
  | REGISTER {
      return $1
    }
  ;

type_specifier
  : VOID {
      return $1
    }
  | CHAR {
      return $1
    }
  | SHORT {
      return $1
    }
  | INT {
      return $1
    }
  | LONG {
      return $1
    }
  | FLOAT {
      return $1
    }
  | DOUBLE {
      return $1
    }
  | SIGNED {
      return $1
    }
  | UNSIGNED {
      return $1
    }
  | BOOL {
      return $1
    }
  | COMPLEX {
      return $1
    }
  | IMAGINARY {
      return $1
    }
  | struct_or_union_specifier {
      return  $1
    }
  | enum_specifier {
      return  $1
    }
  | TYPE_NAME {
      return  $1
    }
  | INT8 {
      return $1
    }
  | INT16 {
      return $1
    }
  | INT32 {
      return $1
    }
  | INT64 {
      return $1
    }
  | UINT8 {
      return $1
    }
  | UINT16 {
      return $1
    }
  | UINT32 {
      return $1
    }
  | UINT64 {
      return $1
    }
  | SELFTYPE {
      return $1
    }
  ;

struct_or_union_specifier
  : struct_or_union IDENTIFIER {
      return {[$1.value] = $2}
    }
  | struct_or_union L_BRACE struct_declaration_list R_BRACE {
      return {[$1.value] = true, decl = $3}
    }
  ;

struct_or_union
  : STRUCT {
      return $1
    }
  | UNION {
      return $1
    }
  ;

struct_declaration_list
  : struct_declaration {
      return {$1}
    }
  | struct_declaration_list struct_declaration {
      $1[#$1+1] = $2
      return $1
    }
  ;

struct_declaration
  : type_name struct_declarator_list SEMICOLON {
      return {decl = $2, ctype = $1}
    }
  | type_name SEMICOLON {
      return {anon = true, ctype = $1}
    }
  ;

specifier_qualifier_list
  : type_specifier specifier_qualifier_list {
      $2.spec[#$2.spec+1] = $1
      return $2
    }
  | type_specifier {
      return {spec = {$1}, qual = {}}
    }
  | type_qualifier specifier_qualifier_list {
      $2.qual[#$2.qual+1] = $1
      return $2
    }
  | type_qualifier {
      return {spec = {}, qual = {$1}}
    }
  ;

struct_declarator_list
  : struct_declarator {
      return {$1}
    }
  | struct_declarator_list COMMA struct_declarator {
      $1[#$1+1] = $3
      return $1
    }
  ;

struct_declarator
  : IDENTIFIER {
      return {iden = $1}
    }
  | IDENTIFIER COLON constant_expression {
      return {iden = $1, width = $3}
    }
  ;

enum_specifier
  : ENUM L_BRACE enumerator_list R_BRACE {
      return {enum = true, list = $3}
    }
  | ENUM L_BRACE enumerator_list COMMA R_BRACE {
      return {enum = true, list = $3}
    }
  | ENUM IDENTIFIER {
      return {enum = $2}
    }
  ;

enumerator_list
  : enumerator {
      return {$1}
    }
  | enumerator_list COMMA enumerator {
      $1[#$1+1] = $3
      return $1
    }
  ;

enumerator
  : IDENTIFIER {
      return {iden = $1}
    }
  | IDENTIFIER ASSIGN constant_expression {
      return {iden = $1, value = $3}
    }
  ;

type_qualifier
  : CONST {
      return $1
    }
  | RESTRICT {
      return $1
    }
  | VOLATILE {
      return $1
    }
  ;

pointer
  : STAR {
      return {{}}
    }
  | STAR type_qualifier_list {
      return {{qual = $1}}
    }
  | STAR pointer {
      return merge({{}}, $2)
    }
  | STAR type_qualifier_list pointer {
      return merge({{qual = $2}}, $3)
    }
  ;

array
  : L_BRACKET type_qualifier_list assignment_expression R_BRACKET {
      return {{qual = $2, expr = $3}}
    }
  | L_BRACKET type_qualifier_list R_BRACKET {
      return {{qual = $2}}
    }
  | L_BRACKET assignment_expression R_BRACKET {
      return {{expr = $2}}
    }
  | L_BRACKET STATIC type_qualifier_list assignment_expression R_BRACKET {
      return {{static = true, qual = $3, expr = $4}}
    }
  | L_BRACKET type_qualifier_list STATIC assignment_expression R_BRACKET {
      return {{static = true, qual = $3, expr = $5}}
    }
  | L_BRACKET R_BRACKET {
      return {{}}
    }
  | array L_BRACKET type_qualifier_list assignment_expression R_BRACKET {
      $1[#$1+1] = {qual = $3, expr = $4}
      return $1
    }
  | array L_BRACKET type_qualifier_list R_BRACKET {
      $1[#$1+1] = {qual = $3}
      return $1
    }
  | array L_BRACKET assignment_expression R_BRACKET {
      $1[#$1+1] = {expr = $3}
      return $1
    }
  | array L_BRACKET STATIC type_qualifier_list assignment_expression R_BRACKET {
      $1[#$1+1] = {static = true, qual = $4, expr = $5}
      return $1
    }
  | array L_BRACKET type_qualifier_list STATIC assignment_expression R_BRACKET {
      $1[#$1+1] = {static = true, qual = $4, expr = $6}
      return $1
    }
  | array L_BRACKET R_BRACKET {
      $1[#$1+1] = {}
      return $1
    }
  ;

function_type
  : type_name COLON {
      return {funcatype = true, ret = $1, list = {}}
    }
  | type_name COLON type_name_list {
      return {funcatype = true, ret = $1, list = $3}
    }
  ;

type_name_list
  : type_name {
      return {$1}
    }
  | type_name_list COMMA type_name {
      $1[#$1+1] = $3
      return $1
    }
  ;

type_qualifier_list
  : type_qualifier {
      return {$1}
    }
  | type_qualifier_list type_qualifier {
      $1[#$1+1] = $2
      return $1
    }
  ;


parameter_type_list
  : parameter_list {
      return $1
    }
  | parameter_list COMMA ELLIPSIS {
      $1.vararg = true
      return $1
    }
  ;

parameter_list
  : parameter_declaration {
      return {$1}
    }
  | parameter_list COMMA parameter_declaration {
      $1[#$1+1] = $3
      return $1
    }

  ;

parameter_declaration
  : type_name IDENTIFIER {
      return {param = $2, ctype = $1}
    }
  ;

type_name
  : specifier_qualifier_list {
      return {sqlist = $1}
    }
  | specifier_qualifier_list abstract_declarator {
      return {sqlist = $1, adecl = $2}
    }
  | L_BRACKET function_type R_BRACKET abstract_declarator {
      return {functype = $2, adecl = $4}
    }
  | L_BRACKET type_name_list R_BRACKET {
      return {tuple = $2}
    }
  | L_BRACKET type_name_list R_BRACKET abstract_declarator {
      return {tuple = $2, adecl = $4}
    }
  ;

abstract_declarator
  : pointer {
      return {pointer = $1}
    }
  | pointer array {
      return {pointer = $1, array = $2}
    }
  | array {
      return {array = $1}
    }
  ;

initializer
  : assignment_expression {
      return {asgnexpr = $1}
    }
  | L_BRACE initializer_list R_BRACE {
      return {initlist = $2}
    }
  | L_BRACE initializer_list COMMA R_BRACE {
      return {initlist = $2}
    }
  ;

initializer_list
  : initializer {
      return {$1}
    }
  | designation initializer {
      $2.desgn = $1
      return {$2}
    }
  | initializer_list COMMA initializer {
      $1[#$1+1] = $3
      return $1
    }
  | initializer_list COMMA designation initializer {
      $4.desgn = $3
      $1[#$1+1] = $4
      return $1
    }
  ;

designation
  : designator_list ASSIGN {
      return $1
    }
  ;

designator_list
  : designator {
      return {$1}
    }
  | designator_list designator {
      $1[#$1+1] = $2
      return $1
    }
  ;

designator
  : L_BRACKET constant_expression R_BRACKET {
      return {index = $2}
    }
  | DOT IDENTIFIER {
      return {iden = $2}
    }
  ;

statement
  : closed_statement {
      return $1
    }
  | opened_statement {
      return $1
    }
  ;

if_clause
  : IF L_PAREN expression R_PAREN {
      return {ifcl = $3}
    }
  ;

do_clause
  : DO {
      return {docl = true}
    }
  ;

for_clause
  : FOR L_PAREN expression_statement expression_statement R_PAREN {
      return {forcl = "ee", init = $3.expr, cond = $4.expr}
    }
  | FOR L_PAREN expression_statement expression_statement expression R_PAREN {
      return {forcl = "eee", init = $3.expr, cond = $4.expr, incr=$5}
    }
  | FOR L_PAREN declaration expression_statement R_PAREN {
      return {forcl = "de", decl = $3, cond = $4.expr}
    }
  | FOR L_PAREN declaration expression_statement expression R_PAREN {
      return {forcl = "dee", decl = $3, cond = $4.expr, incr=$5}
    }
  ;

while_clause
  : WHILE L_PAREN expression R_PAREN {
      return {whilecl = $3}
    }
  ;

label
  : IDENTIFIER COLON {
      return {label = $1}
    }
  | CASE constant_expression COLON {
      return {case = $2}
    }
  | DEFAULT COLON {
      return {default = true}
    }
  ;

switch_clause
  : SWITCH L_PAREN expression R_PAREN {
      return {switchcl = $3}
    }
  ;


opened_statement
  : if_clause statement {
      $1.dstmt = $2
      $1.opened = true
      return $1
    }
  | if_clause closed_statement ELSE opened_statement{
      $1.dstmt = $2
      $1.estmt = $4
      $1.opened = true
      return $1
    }
  | do_clause opened_statement while_clause SEMICOLON {
      $1.dstmt = $2
      $1.docl = $3.whilecl
      $1.opened = true
      return $1
    }
  | for_clause opened_statement {
      $1.dstmt = $2
      $1.opened = true
      return $1
    }
  | while_clause opened_statement {
      $1.dstmt = $2
      $1.opened = true
      return $1
    }
  ;

closed_statement
  : if_clause closed_statement ELSE closed_statement {
      $1.dstmt = $2
      $1.estmt = $4
      $1.opened = false
      return $1
    }
  | do_clause closed_statement while_clause SEMICOLON {
      $1.docl = $3.whilecl
      $1.dstmt = $2
      $1.opened = false
      return $1
    }
  | for_clause closed_statement {
      $1.dstmt = $2
      $1.opened = false
      return $1
    }
  | while_clause closed_statement {
      $1.dstmt = $2
      $1.opened = false
      return $1
    }
  | expression_statement {
      return $1
    }
  | jump_statement {
      return $1
    }
  | label {
      return $1
    }
  | switch_clause compound_statement {
      $1.dstmt = {compound = $2}
      $1.opened = false
      return $1
    }
  | compound_statement {
      return {compound = $1}
    }
  ;

compound_statement
  : L_BRACE R_BRACE {
      return {}
    }
  | L_BRACE block_item_list R_BRACE {
      return $2
    }
  ;


block_item_list
  : block_item {
      return {$1}
    }
  | block_item_list block_item {
      $1[#$1+1] = $2
      return $1
    }
  ;

block_item
  : declaration {
      return {decl = $1}
    }
  | statement {
      return {stmt = $1}
    }
  ;

expression_statement
  : SEMICOLON {
      return {empty = true}
    }
  | expression SEMICOLON {
      return {expr = $1}
    }
  ;


jump_statement
  : GOTO IDENTIFIER SEMICOLON {
      return {gotostmt = $2}
    }
  | CONTINUE SEMICOLON {
      return {contstmt = $1}
    }
  | BREAK SEMICOLON {
      return {breakstmt = $1}
    }
  | RETURN SEMICOLON {
      return {retstmt = true}
    }
  | RETURN expression SEMICOLON {
      return {retstmt = $2}
    }
  ;

source
  : translation_unit
    {
      env.tree = $1
      return $1
    }
  ;

translation_unit
  : external_declaration {
      return {$1}
    }
  | translation_unit external_declaration {
      $1[#$1+1] = $2
      return $1
    }
  ;

external_declaration
  : function_definition {
      return $1
    }
  | declaration {
      return $1
    }
  | interface_definition {
      return $1
    }
  | namespace {
      return $1
    }
  ;

namespace
  : NAMESPACE IDENTIFIER L_BRACE R_BRACE SEMICOLON {
      return {ns = $2, list = {}}
    }
  | NAMESPACE IDENTIFIER L_BRACE namespace_declaration R_BRACE SEMICOLON {
      return {ns = $2, list = $4}
    }
  ;

namespace_declaration
  : external_declaration {
      return {$1}
    }
  | namespace_declaration external_declaration {
      $1[#$1+1] = $2
      return $1
    }
  ;

interface_definition
  : INTERFACE IDENTIFIER L_BRACE interface_declaration interface_definition_block R_BRACE SEMICOLON {
      return {iface = $2, idecl = $4, idef = $5}
    }
  ;

interface_declaration
  : DECLARE struct_or_union_specifier SEMICOLON {
      return $1
    }
  ;


interface_definition_block
  : method_definition_list
  | interface_derrivation method_definition_list
  ;

interface_derrivation
  : INTERFACE IDENTIFIER SEMICOLON
  | INTERFACE IDENTIFIER L_BRACE method_definition_list R_BRACE SEMICOLON
  ;

method_definition_list
  : method_definition
  | method_definition_list method_definition
  ;

method_definition
  : function_definition
  ;

function_specifier_list
  : function_specifier {
      return {$1}
    }
  | function_specifier_list function_specifier {
      $1[#$1+1] = $2
      return $1
    }
  ;

function_specifier
  : INLINE {
      return $1
    }
  | EXPORT {
      return $1
    }
  | HIDDEN {
      return $1
    }
  ;

function_definition
  : type_name IDENTIFIER L_PAREN R_PAREN compound_statement {
      return {funcdef = $2, rctype = $1, list = {}, block = $5}
    }
  | function_specifier_list type_name IDENTIFIER L_PAREN R_PAREN compound_statement {
      return {spec = $1, funcdef = $3, rctype = $2, list = {}, block = $6}
    }
  | type_name IDENTIFIER L_PAREN parameter_type_list R_PAREN compound_statement {
      return {funcdef = $2, rctype = $1, list = $4, block = $6}
    }
  | function_specifier_list type_name IDENTIFIER L_PAREN parameter_type_list R_PAREN compound_statement {
      return {spec = $1, funcdef = $3, rctype = $2, list = $5, block = $7}
    }

  | type_name IDENTIFIER L_PAREN R_PAREN SEMICOLON {
      return {funcdef = $2, rctype = $1, list = {}, block = $5, forward = true}
    }
  | function_specifier_list type_name IDENTIFIER L_PAREN R_PAREN SEMICOLON {
      return {spec = $1, funcdef = $3, rctype = $2, list = {}, block = $6, forward = true}
    }
  | type_name IDENTIFIER L_PAREN parameter_type_list R_PAREN SEMICOLON {
      return {funcdef = $2, rctype = $1, list = $4, block = $6, forward = true}
    }
  | function_specifier_list type_name IDENTIFIER L_PAREN parameter_type_list R_PAREN SEMICOLON {
      return {spec = $1, funcdef = $3, rctype = $2, list = $5, block = $7, forward = true}
    }
  ;

